<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Luke Irvine Collisions</title>

    <!-- Babylon.js -->
    <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- <script src="https://cdn.babylonjs.com/cannon.js"></script> -->
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        // flag
        var simple = true;


        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };

        /* ==== function moveSprite ====
         * min and max are bounds for sprite cells
         * delay is modulo number to slow down frame rate
         * total is total number of cells in sprite
         * index is used for slowing frame rate
         * walkingThor is sprite object
         */
         function moveSprite(min, max, delay, total, index, walkingThor) {
            if (index % delay === 0) {
                if (walkingThor.cellIndex < min || walkingThor.cellIndex > max) {
                    walkingThor.cellIndex = min;
                }
                walkingThor.cellIndex = (walkingThor.cellIndex + 1) % (total + 1);
                if (walkingThor.cellIndex > max) {
                    walkingThor.cellIndex = min;
                }
            }
        }

        /* ==== Recursive Maze Function ====
        * 
        * 
        * 
        */
        function carve_passages_from(cx, cy, grid, wallArray, myStack, index) {
            // new x and y indices
            var nx;
            var ny;
            // iterator
            var i;
            // array holding cardinal directions, shuffled for random
            var N = -1;
            var S = 1;
            var W = -2;
            var E = 2;
            var directions = [N, S, W, E];
            shuffle(directions);
            // set 1 at current cell so we know we've been here
            grid[cy][cx] = 1;

            console.log("cy");
            console.log(cy);
            console.log("cx");
            console.log(cx);

            for (i = 0; i < directions.length; i++) {
                if (directions[i] === E || directions[i] === W) {
                    nx = cx + directions[i] / 2;
                    ny = cy;
                }
                else {
                    nx = cx;
                    ny = cy + directions[i];
                }
                if ( (nx >= 0 && nx < grid[0].length) && (ny >= 0 && ny < grid.length) && grid[ny][nx] === 0) {
                    // new cell is inbounds and not visited
                    myStack.push(cx);
                    myStack.push(cy);
                    // INSERT tear down wall
                    if (directions[i] === N) {
                        wallArray[2 * cy + 1 + N][cx].dispose();
                        wallArray[2 * cy + 1 + N][cx] = 0;
                        console.log("tear down wall at:");
                        console.log(2 * cy + 1 + N);
                        console.log(cx);
                    }
                    if (directions[i] === S) {
                        wallArray[2 * cy + 1 + S][cx].dispose();
                        wallArray[2 * cy + 1 + S][cx] = 0;
                        console.log("tear down wall at:");
                        console.log(2 * cy + 1 + + S);
                        console.log(cx);
                    }
                    if (directions[i] === E) {
                        wallArray[2 * cy + 1][cx + E / 2].dispose();
                        wallArray[2 * cy + 1][cx + E / 2] = 0;
                        console.log("tear down wall at:");
                        console.log(2 * cy + 1);
                        console.log(cx + E / 2);
                    }
                    if (directions[i] === W) {
                        wallArray[2 * cy + 1][cx].dispose();
                        wallArray[2 * cy + 1][cx] = 0;
                        console.log("tear down wall at:");
                        console.log(2 * cy + 1);
                        console.log(cx);
                    }
                    index++;
                    console.log("moving forward");
                    carve_passages_from(nx, ny, grid, wallArray, myStack, index);
                }
            }
            if (myStack.length === 0 && index != 0) {
                return 0;
            }
            var py = myStack.pop();
            var px = myStack.pop();
            index++;
            console.log("moving backward")
            carve_passages_from(px, py, grid, wallArray, myStack, index);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

                // swap elements array[i] and array[j]
                // we use "destructuring assignment" syntax to achieve that
                // you'll find more details about that syntax in later chapters
                // same can be written as:
                // let t = array[i]; array[i] = array[j]; array[j] = t
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function sleep(milliseconds) {
            const date = Date.now();
            let currentDate = null;
            do {
                currentDate = Date.now();
            } while (currentDate - date < milliseconds);
        }


/********************************************************************************************************************************/

        var createScene = function () {

            // Create the scene space
            var scene = new BABYLON.Scene(engine);
            scene.collisionsEnabled = true;
            scene.enablePhysics(new BABYLON.Vector3(0, -50, 0), new BABYLON.OimoJSPlugin());

            // var options = new BABYLON.SceneOptimizerOptions();
            // // Optimizer
            // var optimizer = new BABYLON.SceneOptimizer(scene, options);
            // options.targetFrameRate(60);

            // textures
            var hedge = new BABYLON.StandardMaterial("hedge", scene);
            hedge.diffuseTexture = new BABYLON.Texture("textures/hedge.png", scene);
            hedge.specularTexture = new BABYLON.Texture("textures/hedge.png", scene);
            hedge.ambientTexture = new BABYLON.Texture("textures/hedge.png", scene);
            hedge.alpha = 1;

            var grass = new BABYLON.StandardMaterial("grass", scene);
            grass.diffuseTexture = new BABYLON.Texture("textures/grass.jpg", scene);
            grass.specularTexture = new BABYLON.Texture("textures/grass.jpg", scene);
            grass.ambientTexture = new BABYLON.Texture("textures/grass.jpg", scene);

            var dirt = new BABYLON.StandardMaterial("grass", scene);
            dirt.diffuseTexture = new BABYLON.Texture("textures/cracked_dirt.jpg", scene);
            dirt.specularTexture = new BABYLON.Texture("textures/cracked_dirt.jpg", scene);
            dirt.ambientTexture = new BABYLON.Texture("textures/cracked_dirt.jpg", scene);

            // for spheres around sprites
            var pMat = new BABYLON.StandardMaterial("pMat", scene);
            pMat.emissiveColor = new BABYLON.Color3(1, 1, 0);
            pMat.alpha = 0;

            // camera
            var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 100, -100), scene);
            camera.setTarget(new BABYLON.Vector3(0, 6, 0));
            camera.attachControl(canvas, true);
            camera.applyGravity = true;
            camera.ellipsoid = new BABYLON.Vector3(1, 14, 1);
            camera.checkCollisions = false;

            // lighting
            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 100, 0), scene);

            // Ground
            var worldWidth = 400;
            var worldDepth = 400;
            var myGround = BABYLON.MeshBuilder.CreateGround("myGround", { width: worldWidth, height: worldDepth, subdivisions: 5 }, scene);
            myGround.material = dirt;
            myGround.checkCollisions = true;
            myGround.physicsImpostor = new BABYLON.PhysicsImpostor(
                myGround, BABYLON.PhysicsImpostor.BoxImpostor,
                { mass: 0, restitution: 1, friction: 0 }, scene);
            // var tiledDirt = BABYLON.MeshBuilder.CreateTiledPlane("dirt", {width: 500, size: 500}, scene);

            // Player Mesh
            var player = BABYLON.MeshBuilder.CreateSphere("player", { diameterY: 6, diameterX: 3, diameterZ: 3 }, scene);
            player.material = pMat;
            player.position = new BABYLON.Vector3(-100, 3, -100);
            player.ellipsoid = new BABYLON.Vector3(2, 7, 2);
            player.checkCollisions = true;
            player.applyGravity = true;
            player.speed = new BABYLON.Vector3(0, 0, 0.08);
            player.nextspeed = new BABYLON.Vector3.Zero();
            player.physicsImpostor = new BABYLON.PhysicsImpostor(
                player, BABYLON.PhysicsImpostor.SphereImpostor,
                { mass: 150, restitution: 0, friction: 1 }, scene);

            // Sprites
            // Walking Thor
            var spriteManagerWalkingThor = new BABYLON.SpriteManager(
                "WalkingThorManager",
                "spritesheets/walking_thor.png",
                64, { width: 800 / 8, height: 800 / 8 }, scene
            );
            var walkingThor = new BABYLON.Sprite("walkingThor", spriteManagerWalkingThor);
            walkingThor.cellIndex = 0;
            walkingThor.size = 6;
            walkingThor.position.y = 3;
            walkingThor.position.x = 0;
            walkingThor.position.z = 0;

            // // Maze Posts
            // var lengthX = worldWidth * 0.8;
            // var lengthZ = worldDepth * 0.8;
            // var subX = 50;
            // var subZ = 50;
            // var subLengthX = lengthX / subX;
            // var subLengthZ = lengthZ / subZ;
            // var i = 0;
            // var j = 0;
            // for (i = 0; i < subZ; i++) {
            //     for (j = 0; j < subX; j++) {
            //         var post = new BABYLON.MeshBuilder.CreateCylinder("post", {diameter: 1, height: 10}, scene);
            //         post.position.y = 5;
            //         post.checkCollisions = true;
            //         post.position.x = subLengthX / 2 + subLengthX * j - lengthX / 2;
            //         post.position.z = subLengthZ / 2 + subLengthZ * i - lengthZ / 2;
            //     }
            // }

            // Maze Wall Grid
            var wallHeight = 10;
            var wallDepth = 4;
            var mazeLength = 50;
            var sub = 3;
            var subLength = mazeLength / sub;
            var i = 0;
            var j = 0;
            var wallArray = [];
            var index = 0;
            for (i = 0; i <= sub * 2; i++) {
                wallArray.push([]);
                for (j = 0; j <= sub; j++) {
                    var mazeWall = new BABYLON.MeshBuilder.CreateBox(
                        "mazeWall",
                        { height: wallHeight, width: subLength, depth: wallDepth },
                        scene);
                    // // index shift
                    // if (i % 2 === 0) {
                    //     wallArray[i].push(0);
                    // }
                    if (!(i === 0 && j === 0) && !(i === 1 && j === 0)) {
                        mazeWall.material = hedge;
                    }
                    mazeWall.checkCollisions = true;
                    mazeWall.position.y = wallHeight / 2;
                    mazeWall.position.z = mazeLength - subLength / 2 * i - mazeLength / 2;
                    if (i % 2 === 0) {
                        if (j < sub) {
                            mazeWall.position.x = subLength / 2 + subLength * j - mazeLength / 2;
                            // console.log("placed horizontal wall at:");
                            // console.log(i);
                            // console.log(j);
                        }
                    }
                    if (i % 2 === 1) {
                        mazeWall.position.x = subLength * j - mazeLength / 2;
                        mazeWall.rotation.y = Math.PI / 2;
                        // console.log("placed vertical wall at:");
                        // console.log(i);
                        // console.log(j);
                    }
                    wallArray[i].push(mazeWall);
                }
            }

            // Maze Generator
            var grid = [];
            // initialize array
            for (i = 0; i < sub; i++) {
                grid.push([]);
                for (j = 0; j < sub; j++) {
                    grid[i].push(0);
                }
            }

            // stack to push previously visited cells
            var myStack = [];
            // start recursive function
            // carve_passages_from(Math.round(sub/2 - 1), sub - 1, grid, wallArray, myStack, index);
            carve_passages_from(0, sub - 1, grid, wallArray, myStack, index);
            wallArray[sub * 2][0].dispose();

            console.log("wallArray[4][1]");
            console.log(wallArray[4][1]);



            /***********************************************************************************************************************************************************/

            // Keypress events
            window.keyisdown = {};
            window.addEventListener('keydown', function (event) {
                window.keyisdown[event.keyCode] = true;
            });

            window.addEventListener('keyup', function (event) {
                window.keyisdown[event.keyCode] = false;
            });

            window.tempv = new BABYLON.Vector3.Zero();

            // modulus for when thing executes
            var delay = 4;
            // total number of cells in sprite
            var totalCells = 64;
            // governs when sprites move
            var index = 0;
            // governs duration of jump
            var startJump = 7;
            var jump = startJump;


            scene.registerBeforeRender(function () {
                walkingThor.position = player.position;
                // Player speed
                var v = 0.15;
                player.nextspeed.x = 0.0;
                player.nextspeed.z = 0.00001;
                index += 1;
                // Left "a"
                if (window.keyisdown[65] && !window.keyisdown[87] && !window.keyisdown[83]) {
                    player.nextspeed.x = -v;
                    moveSprite(8, 15, delay, totalCells, index, walkingThor);
                }
                // Right "d"
                if (window.keyisdown[68] && !window.keyisdown[87] && !window.keyisdown[83]) {
                    player.nextspeed.x = v;
                    moveSprite(16, 23, delay, totalCells, index, walkingThor);
                }
                // Up "w"
                if (window.keyisdown[87] && !window.keyisdown[65] && !window.keyisdown[68]) {
                    player.nextspeed.z = v;
                    moveSprite(24, 31, delay, totalCells, index, walkingThor);
                }
                // Down "s"
                if (window.keyisdown[83] && !window.keyisdown[65] && !window.keyisdown[68]) {
                    player.nextspeed.z = -v;
                    moveSprite(0, 7, delay, totalCells, index, walkingThor);
                }

                // MultiDirectional

                // UpLeft
                if (window.keyisdown[65] && window.keyisdown[87]) {
                    player.nextspeed.x = -v;
                    player.nextspeed.z = v;
                    moveSprite(40, 47, delay, totalCells, index, walkingThor);
                }
                // UpRight
                if (window.keyisdown[68] && window.keyisdown[87]) {
                    player.nextspeed.x = v;
                    player.nextspeed.z = v;
                    moveSprite(56, 63, delay, totalCells, index, walkingThor);
                }
                // BottomRight
                if (window.keyisdown[68] && window.keyisdown[83]) {
                    player.nextspeed.x = v;
                    player.nextspeed.z = -v;
                    moveSprite(48, 55, delay, totalCells, index, walkingThor);
                }
                // BottomLeft
                if (window.keyisdown[65] && window.keyisdown[83]) {
                    player.nextspeed.x = -v;
                    player.nextspeed.z = -v;
                    moveSprite(32, 39, delay, totalCells, index, walkingThor);
                }
                // Top Three (a, w, d)
                if (window.keyisdown[87] && window.keyisdown[65] && window.keyisdown[68]) {
                    player.nextspeed.z = v;
                    moveSprite(24, 31, delay, totalCells, index, walkingThor);
                }
                // Bottom Three (a, s, d)
                if (window.keyisdown[83] && window.keyisdown[65] && window.keyisdown[68]) {
                    player.nextspeed.z = -v;
                    moveSprite(0, 7, delay, totalCells, index, walkingThor);
                }



                player.speed = BABYLON.Vector3.Lerp(player.speed, player.nextspeed, 0.1);
                player.moveWithCollisions(player.speed);

                if (player.position.x > 250) { player.position.x = 250; }
                if (player.position.x < -250) { player.position.x = -250; }
                if (player.position.z > 250) { player.position.z = 250; }
                if (player.position.z < -250) { player.position.z = -250; }
                if (window.keyisdown[32]) {
                    jump -= 1;
                    if (jump > 0) {
                        player.applyImpulse(new BABYLON.Vector3(0, 4, 0), player.getAbsolutePosition());
                    }
                }
                if (!window.keyisdown[32]) {
                    jump = startJump;
                }

                // player.nexttorch = lightImpostor.getAbsolutePosition();
                // torch.position.copyFrom(player.nexttorch);
                // torch.intensity = 0.7 + Math.random() * 0.1;
                // torch.position.x += Math.random() * 0.125 - 0.0625;
                // torch.position.z += Math.random() * 0.125 - 0.0625;
                // camera.target = player;
            });

            // /*********************************************************************************************************************/

            return scene;
        }


        engine = createDefaultEngine();
        if (!engine) throw 'engine should not be null.';
        scene = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>