<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Maze - Luke Irvine</title>

    <!-- Babylon.js -->
    <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <!-- <script src="https://cdn.babylonjs.com/cannon.js"></script> -->
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        // flag
        var simple = true;


        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene0 = null;
        var scene1 = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };

        // variables to govern scene switching
        // var clicks = 1;
        // var showScene = 0;
        var nextScene = false;
        var advancedTexture;
        var sub = 10;
        var soundtrack;
        var replay = true;

        // global gui variables
        // var timerStart = false;


        /************************************************* scene0: Welcome Menu *****************************************************************/
        // this scene has the welcome and options menu
        var createScene0 = function () {
            // Create the scene1 space
            var scene0 = new BABYLON.Scene(engine);

            var camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 5, new BABYLON.Vector3(0, 0, 0), scene0);
            camera.setPosition(new BABYLON.Vector3(2, 2, 5));
            camera.attachControl(canvas, true);

            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene0);

            // Music
            var volume = 1;
            soundtrack = new BABYLON.Sound(
                "soundtrack",
                "sounds/our_universe.wav",
                scene0,
                null,
                {
                    volume: volume,
                    autoplay: true,
                    loop: true
                }
            );

            // add gui for just scene0
            var box = new BABYLON.MeshBuilder.CreateBox("box", { width: 1, height: 1, depth: 1 }, scene0);
            return scene0;
        }

        /*************************************************** scene1: The Game *******************************************************************/

        var createScene1 = function () {

            // Create the scene1 space
            var scene1 = new BABYLON.Scene(engine);
            scene1.collisionsEnabled = true;
            scene1.enablePhysics(new BABYLON.Vector3(0, -50, 0), new BABYLON.OimoJSPlugin());

            // Tweaking Variables
            var elevation = 10;
            var wallHeight = 10;                // don't adjust
            var wallDepth = 4;                  // don't adjust
            var mazeLength = sub * 10;
            var subLength = mazeLength / sub;
            var groundSize = mazeLength + sub * 20;
            var follow = true;                  // true makes camera follow player. False gives bird's eye
            var cameraGravity = true;           // only works for Universal Camera

            // textures
            var hedge = new BABYLON.StandardMaterial("hedge", scene1);
            hedge.diffuseTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            hedge.specularTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            hedge.ambientTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            hedge.alpha = 1;

            var rock = new BABYLON.StandardMaterial("rock", scene1);
            rock.diffuseTexture = new BABYLON.Texture("textures/rock.jpg", scene1);
            rock.specularTexture = new BABYLON.Texture("textures/rock.jpg", scene1);
            rock.ambientTexture = new BABYLON.Texture("textures/rock.jpg", scene1);

            var stone = new BABYLON.StandardMaterial("stone", scene1);
            var tileCount = Math.round(sub * 0.83);
            stone.diffuseTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone.specularTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone.ambientTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone.diffuseTexture.uScale = tileCount;
            stone.diffuseTexture.vScale = tileCount;
            stone.specularTexture.uScale = tileCount;
            stone.specularTexture.vScale = tileCount;
            stone.ambientTexture.uScale = tileCount;
            stone.ambientTexture.vScale = tileCount;

            var bigHedge = new BABYLON.StandardMaterial("bigHedge", scene1);
            var tileCount2 = Math.round(groundSize / (sub * 4));
            bigHedge.diffuseTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            bigHedge.specularTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            bigHedge.ambientTexture = new BABYLON.Texture("textures/hedge.png", scene1);
            bigHedge.diffuseTexture.uScale = tileCount2;
            bigHedge.diffuseTexture.vScale = tileCount2;
            bigHedge.specularTexture.uScale = tileCount2;
            bigHedge.specularTexture.vScale = tileCount2;
            bigHedge.ambientTexture.uScale = tileCount2;
            bigHedge.ambientTexture.vScale = tileCount2;

            var grass = new BABYLON.StandardMaterial("grass", scene1);
            var tileCount4 = Math.round(sub * 1.5)
            grass.diffuseTexture = new BABYLON.Texture("textures/grassy.jpg", scene1);
            grass.specularTexture = new BABYLON.Texture("textures/grassy.jpg", scene1);
            grass.ambientTexture = new BABYLON.Texture("textures/grassy.jpg", scene1);
            grass.diffuseTexture.uScale = tileCount4;
            grass.diffuseTexture.vScale = tileCount4 / 3;
            grass.specularTexture.uScale = tileCount4;
            grass.specularTexture.vScale = tileCount4 / 3;
            grass.ambientTexture.uScale = tileCount4;
            grass.ambientTexture.vScale = tileCount4 / 3;

            var dirt = new BABYLON.StandardMaterial("dirt", scene1);
            dirt.diffuseTexture = new BABYLON.Texture("textures/dirt.jpg", scene1);
            dirt.specularTexture = new BABYLON.Texture("textures/dirt.jpg", scene1);
            dirt.ambientTexture = new BABYLON.Texture("textures/dirt.jpg", scene1);
            dirt.diffuseTexture.uScale = tileCount4;
            dirt.diffuseTexture.vScale = tileCount4;
            dirt.specularTexture.uScale = tileCount4;
            dirt.specularTexture.vScale = tileCount4;
            dirt.ambientTexture.uScale = tileCount4;
            dirt.ambientTexture.vScale = tileCount4;

            var rockTile = new BABYLON.StandardMaterial("stone", scene1);
            var tileCount3 = Math.round(groundSize / (sub * 2));
            rockTile.diffuseTexture = new BABYLON.Texture("textures/rock.jpg", scene1);
            rockTile.specularTexture = new BABYLON.Texture("textures/rock.jpg", scene1);
            rockTile.ambientTexture = new BABYLON.Texture("textures/rock.jpg", scene1);
            rockTile.diffuseTexture.uScale = tileCount3;
            rockTile.diffuseTexture.vScale = 1;
            rockTile.specularTexture.uScale = tileCount3;
            rockTile.specularTexture.vScale = 1;
            rockTile.ambientTexture.uScale = tileCount3;
            rockTile.ambientTexture.vScale = 1;

            var stone2 = new BABYLON.StandardMaterial("stone", scene1);
            var tileCount = Math.round(sub * 0.83);
            stone2.diffuseTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone2.specularTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone2.ambientTexture = new BABYLON.Texture("textures/stone.jpg", scene1);
            stone2.diffuseTexture.uScale = tileCount;
            stone2.diffuseTexture.vScale = 1;
            stone2.specularTexture.uScale = tileCount;
            stone2.specularTexture.vScale = 1;
            stone2.ambientTexture.uScale = tileCount;
            stone2.ambientTexture.vScale = 1;

            // for spheres around sprites
            var pMat = new BABYLON.StandardMaterial("pMat", scene1);
            pMat.emissiveColor = new BABYLON.Color3(1, 1, 0);
            pMat.alpha = 0;

            // Music
            if (replay) {
                var volume = 1;
                soundtrack = new BABYLON.Sound(
                    "soundtrack",
                    "sounds/forbidden_valley_gate.wav",
                    scene1,
                    null,
                    {
                        volume: volume,
                        autoplay: true,
                        loop: true
                    }
                );
            }

            // Cameras
            if (follow) {
                // follow camera
                var followCam = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 20, -groundSize / 2), scene1);
                followCam.radius = 15;
                followCam.heightOffset = 30;
                followCam.rotationOffset = 180;
                followCam.cameraAcceleration = 0.115
                followCam.maxCameraSpeed = 10
                // followCam.attachControl(canvas, true);
            }
            else {
                // Universe Camera
                var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, sub * 12, -100), scene1);
                camera.setTarget(new BABYLON.Vector3(0, 6, 0));
                camera.attachControl(canvas, true);
                camera.applyGravity = cameraGravity;
                camera.ellipsoid = new BABYLON.Vector3(1, 14, 1);
                camera.checkCollisions = true;
            }

            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("myUI");

            // Scene Lighting
            var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 100, 0), scene1);
            // light.diffuse = new BABYLON.Color3(0.3, 0.3, 0.3);
            // var playerLight = new BABYLON.PointLight("lamplight", new BABYLON.Vector3(-subLength / 2, 3, -mazeLength / 2 - mazeLength * 0.05), scene1);
            // playerLight.diffuse = new BABYLON.Color3(0.9, 0.7, 0.4);
            // playerLight.specular = new BABYLON.Color3(0.4, 0.2, 0);

            // Ground
            var myGround = BABYLON.MeshBuilder.CreateGround("myGround", { width: groundSize, height: groundSize, subdivisions: 5 }, scene1);
            myGround.material = dirt;
            myGround.checkCollisions = true;
            myGround.physicsImpostor = new BABYLON.PhysicsImpostor(
                myGround, BABYLON.PhysicsImpostor.BoxImpostor,
                { mass: 0, restitution: 1, friction: 0 }, scene1);

            // floor of maze
            var floor = new BABYLON.MeshBuilder.CreateBox("floor", { width: mazeLength, depth: mazeLength + wallDepth, height: 0.5 }, scene1);
            floor.material = stone;
            floor.position.y = elevation - 0.2;

            // Outer Wall
            var bigWallHeight = 50 + elevation;
            var northWall = new BABYLON.MeshBuilder.CreateBox("northWall", { height: bigWallHeight, width: groundSize, depth: 20 }, scene1);
            northWall.position.z = groundSize / 2 + 10;
            northWall.position.y = bigWallHeight / 2;
            northWall.checkCollisions = true;
            northWall.material = bigHedge;

            var eastWall = new BABYLON.MeshBuilder.CreateBox("northWall", { height: bigWallHeight, width: groundSize, depth: 20 }, scene1);
            eastWall.position.x = groundSize / 2 + 10;
            eastWall.position.y = bigWallHeight / 2;
            eastWall.rotation.y = Math.PI / 2;
            eastWall.checkCollisions = true;
            eastWall.material = bigHedge;

            var westWall = new BABYLON.MeshBuilder.CreateBox("northWall", { height: bigWallHeight, width: groundSize, depth: 20 }, scene1);
            westWall.position.x = -(groundSize / 2 + 10);
            westWall.position.y = bigWallHeight / 2;
            westWall.rotation.y = Math.PI / 2;
            westWall.checkCollisions = true;
            westWall.material = bigHedge;

            var southWall = new BABYLON.MeshBuilder.CreateBox("northWall", { height: bigWallHeight, width: groundSize, depth: 20 }, scene1);
            southWall.position.z = -(groundSize / 2 + 10);
            southWall.position.y = bigWallHeight / 2;
            southWall.checkCollisions = true;
            southWall.material = bigHedge;

            // Elevated Floor
            if (elevation != 0) {
                var trenchSize = 10;
                var southGroundLeft = new BABYLON.MeshBuilder.CreateBox("southGroundLeft", { height: elevation, width: (groundSize - mazeLength) / 2, depth: groundSize / 2 - trenchSize / 2 }, scene1);
                southGroundLeft.material = grass;
                southGroundLeft.position.z = -(groundSize / 4 + trenchSize / 4);
                southGroundLeft.position.y = elevation / 2;
                southGroundLeft.position.x = -(mazeLength / 2 + ((groundSize - mazeLength) / 2) / 2);
                southGroundLeft.checkCollisions = true;
                southGroundLeft.physicsImpostor = new BABYLON.PhysicsImpostor(
                    southGroundLeft, BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 1, friction: 0 }, scene1);

                var southGroundRight = new BABYLON.MeshBuilder.CreateBox("southGroundLeft", { height: elevation, width: (groundSize - mazeLength) / 2, depth: groundSize / 2 - trenchSize / 2 }, scene1);
                southGroundRight.material = grass;
                southGroundRight.position.z = -(groundSize / 4 + trenchSize / 4);
                southGroundRight.position.y = elevation / 2;
                southGroundRight.position.x = mazeLength / 2 + ((groundSize - mazeLength) / 2) / 2;
                southGroundRight.checkCollisions = true;
                southGroundRight.physicsImpostor = new BABYLON.PhysicsImpostor(
                    southGroundRight, BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 1, friction: 0 }, scene1);

                var northGroundLeft = new BABYLON.MeshBuilder.CreateBox("southGroundLeft", { height: elevation, width: (groundSize - mazeLength) / 2, depth: groundSize / 2 - trenchSize / 2 }, scene1);
                northGroundLeft.material = grass;
                northGroundLeft.position.z = groundSize / 4 + trenchSize / 4;
                northGroundLeft.position.y = elevation / 2;
                northGroundLeft.position.x = -(mazeLength / 2 + ((groundSize - mazeLength) / 2) / 2);
                northGroundLeft.checkCollisions = true;
                northGroundLeft.physicsImpostor = new BABYLON.PhysicsImpostor(
                    northGroundLeft, BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 1, friction: 0 }, scene1);

                var northGroundRight = new BABYLON.MeshBuilder.CreateBox("southGroundLeft", { height: elevation, width: (groundSize - mazeLength) / 2, depth: groundSize / 2 - trenchSize / 2 }, scene1);
                northGroundRight.material = grass;
                northGroundRight.position.z = groundSize / 4 + trenchSize / 4;
                northGroundRight.position.y = elevation / 2;
                northGroundRight.position.x = mazeLength / 2 + ((groundSize - mazeLength) / 2) / 2;
                northGroundRight.checkCollisions = true;
                northGroundRight.physicsImpostor = new BABYLON.PhysicsImpostor(
                    northGroundRight, BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 1, friction: 0 }, scene1);

                var centerGround = new BABYLON.MeshBuilder.CreateBox("southGroundLeft", { height: elevation, width: mazeLength, depth: groundSize }, scene1);
                centerGround.material = grass;
                centerGround.position.y = elevation / 2;
                centerGround.checkCollisions = true;
                centerGround.physicsImpostor = new BABYLON.PhysicsImpostor(
                    centerGround, BABYLON.PhysicsImpostor.BoxImpostor,
                    { mass: 0, restitution: 1, friction: 0 }, scene1);

                // var lowerWall = new BABYLON.MeshBuilder.CreateBox("lowerWall", {height: elevation, width: mazeLength + wallDepth, depth: trenchSize}, scene1);
                // lowerWall.checkCollisions = true;
                // lowerWall.material = hedge;
                // lowerWall.position.y = elevation / 2;

                var northEdge = new BABYLON.MeshBuilder.CreateBox("northEdge", { height: elevation, width: groundSize, depth: 0.1 }, scene1);
                northEdge.position.z = trenchSize / 2;
                northEdge.position.y = elevation / 2;
                northEdge.material = stone2;

                var westEdge = new BABYLON.MeshBuilder.CreateBox("northEdge", { height: elevation - 0.1, width: groundSize, depth: 0.1 }, scene1);
                westEdge.position.y = elevation / 2;
                westEdge.position.x = -(mazeLength / 2 + wallDepth / 2);
                westEdge.rotation.y = -Math.PI / 2;
                westEdge.material = stone2;
                westEdge.setCollisions = true;

                var eastEdge = new BABYLON.MeshBuilder.CreateBox("northEdge", { height: elevation - 0.1, width: groundSize, depth: 0.1 }, scene1);
                eastEdge.position.y = elevation / 2;
                eastEdge.position.x = mazeLength / 2 + wallDepth / 2;
                eastEdge.rotation.y = Math.PI / 2;
                eastEdge.material = stone2;
                eastEdge.setCollisions = true;

            }

            // Trees
            // Create a sprite manager to optimize GPU ressources
            // Parameters : name, imgUrl, capacity, cellSize, scene1
            var spriteManagerTrees = new BABYLON.SpriteManager("treesManager", "textures/pine.png", 2000, { width: 394, height: 537 }, scene1);

            // Trees at random positions
            for (var i = 0; i < sub * 20; i++) {
                // mesh around trees
                var treeMesh = BABYLON.MeshBuilder.CreateSphere("treeMesh", { diameterY: 20, diameterX: 6, diameterZ: 7 }, scene1);
                treeMesh.position.y = 7 + elevation;
                treeMesh.material = pMat;
                treeMesh.checkCollisions = true;

                do {
                    var xSpot = Math.random() * groundSize - groundSize / 2;
                    var zSpot = Math.random() * groundSize - groundSize / 2;
                } while (((xSpot > -mazeLength / 2 - 8 && xSpot < mazeLength / 2 + 8) && (zSpot > -mazeLength / 2 - 8 && zSpot < mazeLength / 2 + 8)) ||
                ((xSpot < 10 + (sub % 2 - 1) * (subLength / 2) && xSpot > -10 + (sub % 2 - 1) * (subLength / 2)) && (zSpot < -mazeLength / 2 && zSpot > -groundSize / 2)) ||
                    (zSpot > -(trenchSize + 2) && zSpot < trenchSize + 2));

                tree = new BABYLON.Sprite("tree", spriteManagerTrees);
                tree.size = 20;
                tree.position.x = xSpot;
                tree.position.z = zSpot;
                treeMesh.position.x = xSpot;
                treeMesh.position.z = zSpot;
                tree.position.y = 7 + elevation;
            }

            // Player Mesh
            var player = BABYLON.MeshBuilder.CreateSphere("player", { diameterY: 6, diameterX: 3, diameterZ: 3 }, scene1);
            player.material = pMat;
            // player.position = new BABYLON.Vector3(-100, 3, -100);
            player.ellipsoid = new BABYLON.Vector3(1, 7, 2.5);
            player.checkCollisions = true;
            player.applyGravity = true;
            player.speed = new BABYLON.Vector3(0, 0, 0.08);
            player.nextspeed = new BABYLON.Vector3.Zero();
            player.physicsImpostor = new BABYLON.PhysicsImpostor(
                player, BABYLON.PhysicsImpostor.SphereImpostor,
                { mass: 150, restitution: 0, friction: 1 }, scene1);
            if (follow) {
                followCam.lockedTarget = player;
            }

            // Sprites

            // Walking Thor
            var spriteManagerWalkingThor = new BABYLON.SpriteManager(
                "WalkingThorManager",
                "spritesheets/walking_thor.png",
                64, { width: 800 / 8, height: 800 / 8 }, scene1
            );
            var walkingThor = new BABYLON.Sprite("walkingThor", spriteManagerWalkingThor);
            walkingThor.cellIndex = 0;
            walkingThor.size = 6;
            walkingThor.position.y = 3 + elevation;
            walkingThor.position.x = 0;
            walkingThor.position.z = 0;

            // Running Thor
            var spriteManagerRunningThor = new BABYLON.SpriteManager(
                "RunningThorManager",
                "spritesheets/running_thor.png",
                64, { width: 800 / 8, height: 800 / 8 }, scene1
            );
            var runningThor = new BABYLON.Sprite("runningThor", spriteManagerRunningThor);
            runningThor.cellIndex = 0;
            runningThor.size = 6;
            runningThor.position.y = 3 + elevation;
            runningThor.position.x = 0;
            runningThor.position.z = 0;

            // Maze Wall Grid
            var i = 0;
            var j = 0;
            var wallArray = [];
            var index = 0;
            for (i = 0; i <= sub * 2; i++) {
                wallArray.push([]);
                for (j = 0; j <= sub; j++) {
                    if (!(i % 2 === 0 && j === sub)) {
                        var mazeWall = new BABYLON.MeshBuilder.CreateBox(
                            "mazeWall",
                            { height: wallHeight + Math.random() * 0.5, width: subLength + subLength * 0.4, depth: wallDepth + Math.random() * 0.2 },
                            scene1);
                    }
                    mazeWall.material = hedge;
                    mazeWall.checkCollisions = true;
                    mazeWall.position.y = wallHeight / 2 + elevation;
                    mazeWall.position.z = mazeLength - subLength / 2 * i - mazeLength / 2;
                    // console.log("placed wall at z:")
                    // console.log(mazeLength - subLength / 2 * i + 50);
                    if (i % 2 === 0) {
                        if (j < sub) {
                            mazeWall.position.x = subLength / 2 + subLength * j - mazeLength / 2;
                            // console.log("placed horizontal wall at:");
                            // console.log(mazeLength - subLength / 2 * i + 50);
                            // console.log(subLength / 2 + subLength * j + 50);
                        }
                    }
                    if (i % 2 === 1) {
                        mazeWall.position.x = subLength * j - mazeLength / 2;
                        mazeWall.rotation.y = Math.PI / 2;
                        // console.log("placed vertical wall at:");
                        // console.log(mazeLength - subLength / 2 * i + 50);
                        // console.log(subLength * j + 50);
                    }
                    wallArray[i].push(mazeWall);
                }
            }

            // Maze Generator --------
            var grid = [];
            // initialize array
            for (i = 0; i < sub; i++) {
                grid.push([]);
                for (j = 0; j < sub; j++) {
                    grid[i].push(0);
                }
            }
            // stack to push previously visited cells
            var myStack = [];
            // start recursive function
            carve_passages_from(0, sub - 1, grid, wallArray, myStack, index);
            // Entrance
            wallArray[sub * 2][Math.round(sub / 2) - 1].dispose();
            delete wallArray[sub * 2][Math.round(sub / 2) - 1];
            // Exit
            wallArray[0][Math.round(sub / 2) - 1].dispose();
            delete wallArray[0][Math.round(sub / 2) - 1];

            // set player where maze entrance is
            if (sub % 2 === 1) {
                player.position = new BABYLON.Vector3(0, 3 + elevation, -mazeLength / 2 - mazeLength * 0.05)
            }
            else {
                player.position = new BABYLON.Vector3(-subLength / 2, 3 + elevation, -mazeLength / 2 - mazeLength * 0.05)
            }

            // Torches
            // var light2 = new BABYLON.PointLight("lamplight", new BABYLON.Vector3(-subLength, 3, -mazeLength / 2 - mazeLength * 0.02), scene1);
            // light2.diffuse = new BABYLON.Color3(0.9, 0.7, 0.4);
            // light2.specular = new BABYLON.Color3(0.4, 0.2, 0);
            var lampstand = BABYLON.MeshBuilder.CreateCylinder("lampstand", { height: 6, diameterTop: 3, diameterBottom: 1.75, tessellation: 24 }, scene1);
            lampstand.position = new BABYLON.Vector3(-subLength + (sub % 2) * (subLength / 2), 3 + elevation, -mazeLength / 2 - 4);
            // lampstand.rotation.z = Math.PI;
            lampstand.material = rock;
            lampstand.checkCollisions = true;
            //lamp 2
            // var light3 = new BABYLON.PointLight("lamplight", new BABYLON.Vector3(0, 3, -mazeLength / 2 - mazeLength * 0.02), scene1);
            // light3.diffuse = new BABYLON.Color3(0.9, 0.7, 0.4);
            // light3.specular = new BABYLON.Color3(0.4, 0.2, 0);
            var lampstand2 = BABYLON.MeshBuilder.CreateCylinder("lampstand", { height: 6, diameterTop: 3, diameterBottom: 1.75, tessellation: 24 }, scene1);
            lampstand2.position = new BABYLON.Vector3((sub % 2) * (subLength / 2), 3 + elevation, -mazeLength / 2 - 4);
            // lampstand2.rotation.z = Math.PI;
            lampstand2.material = rock;
            lampstand2.checkCollisions = true;

            // Fire
            var sparks = new BABYLON.ParticleSystem("sparks", 1000, scene1);
            sparks.particleTexture = new BABYLON.Texture("textures/fire.png", scene1);
            sparks.emitter = new BABYLON.Vector3(-subLength + (sub % 2) * (subLength / 2), 6 + elevation, -mazeLength / 2 - 4);
            sparks.minEmitBox = new BABYLON.Vector3(-0.5, 0, 0.5);
            sparks.maxEmitBox = new BABYLON.Vector3(0.5, 0, -0.5);
            sparks.color1 = new BABYLON.Color4(0.7, 0, 0, 1.0);
            sparks.color2 = new BABYLON.Color4(0.5, 0.5, 0, 1.0);
            sparks.minSize = 0.4;
            sparks.maxSize = 1.5;
            sparks.minLifeTime = 0.2;
            sparks.maxLifeTime = 0.5;
            sparks.emitRate = 4000;
            sparks.direction1 = new BABYLON.Vector3(0, 3, 0);
            sparks.direction2 = new BABYLON.Vector3(0, 1.5, 0);
            sparks.minEmitPower = 1;
            sparks.maxEmitPower = 7;
            sparks.updateSpeed = 0.005;
            sparks.start();

            var sparks2 = new BABYLON.ParticleSystem("sparks", 1000, scene1);
            sparks2.particleTexture = new BABYLON.Texture("textures/fire.png", scene1);
            sparks2.emitter = new BABYLON.Vector3((sub % 2) * (subLength / 2), 6 + elevation, -mazeLength / 2 - 4);
            sparks2.minEmitBox = new BABYLON.Vector3(-0.5, 0, 0.5);
            sparks2.maxEmitBox = new BABYLON.Vector3(0.5, 0, -0.5);
            sparks2.color1 = new BABYLON.Color4(0.7, 0, 0, 1.0);
            sparks2.color2 = new BABYLON.Color4(0.5, 0.5, 0, 1.0);
            sparks2.minSize = 0.4;
            sparks2.maxSize = 1.5;
            sparks2.minLifeTime = 0.2;
            sparks2.maxLifeTime = 0.5;
            sparks2.emitRate = 4000;
            sparks2.direction1 = new BABYLON.Vector3(0, 3, 0);
            sparks2.direction2 = new BABYLON.Vector3(0, 1.5, 0);
            sparks2.minEmitPower = 1;
            sparks2.maxEmitPower = 7;
            sparks2.updateSpeed = 0.005;
            sparks2.start();



            /***********************************************************************************************************************************************************/

            // Keypress events
            window.keyisdown = {};
            window.addEventListener('keydown', function (event) {
                window.keyisdown[event.keyCode] = true;
            });

            window.addEventListener('keyup', function (event) {
                window.keyisdown[event.keyCode] = false;
            });

            window.tempv = new BABYLON.Vector3.Zero();

            // total number of cells in sprite
            var totalCells = 64;
            // governs when sprites move
            var index = 0;

            scene1.registerBeforeRender(function () {
                // bird's eye view for z && o
                if (follow) {
                    if (window.keyisdown[90] && window.keyisdown[79]
                        && -mazeLength / 2 < player.position.x && player.position.x < mazeLength / 2    // only lets you zoom out when inside the maze
                        && -mazeLength / 2 < player.position.z && player.position.z < mazeLength / 2
                    ) {
                        // Zoom out
                        followCam.radius = sub * 9;
                        followCam.heightOffset = sub * 9;
                        followCam.rotationOffset = 180;
                    }
                    else {
                        // Zoom in
                        followCam.radius = 15;
                        followCam.heightOffset = 30;
                    }
                }
                // Player Torch: 
                // playerLight.position = player.position;


                // Player Walking or Running
                // delay variable is loop interval at which player sprite operates (uses modulus)
                // when space bar is pressed, run.
                if (!window.keyisdown[32]) {
                    var v = 0.15;
                    var delay = 6;
                    walkingThor.position = player.position;
                    runningThor.position.y = player.position.y - 10;
                }
                else {
                    var v = 0.45;
                    var delay = 4;
                    runningThor.position = player.position;
                    walkingThor.position.y = player.position.y - 10;
                }
                player.nextspeed.x = 0.0;
                player.nextspeed.z = 0.00001;
                index += 1;
                // Left "a"
                if (window.keyisdown[65] && !window.keyisdown[87] && !window.keyisdown[83]) {
                    player.nextspeed.x = -v;
                    moveSprite(8, 15, delay, totalCells, index, walkingThor);
                    // if running
                    moveSprite(8, 15, delay, totalCells, index, runningThor);
                }
                // Right "d"
                if (window.keyisdown[68] && !window.keyisdown[87] && !window.keyisdown[83]) {
                    player.nextspeed.x = v;
                    moveSprite(16, 23, delay, totalCells, index, walkingThor);
                    moveSprite(16, 23, delay, totalCells, index, runningThor);
                }
                // Up "w"
                if (window.keyisdown[87] && !window.keyisdown[65] && !window.keyisdown[68]) {
                    player.nextspeed.z = v;
                    moveSprite(24, 31, delay, totalCells, index, walkingThor);
                    moveSprite(24, 31, delay, totalCells, index, runningThor);
                }
                // Down "s"
                if (window.keyisdown[83] && !window.keyisdown[65] && !window.keyisdown[68]) {
                    player.nextspeed.z = -v;
                    moveSprite(0, 7, delay, totalCells, index, walkingThor);
                    moveSprite(0, 7, delay, totalCells, index, runningThor);
                }

                // MultiDirectional

                // UpLeft
                if (window.keyisdown[65] && window.keyisdown[87]) {
                    player.nextspeed.x = - Math.sqrt(Math.pow(v, 2) / 2);   // makes trig combination equal to v
                    player.nextspeed.z = Math.sqrt(Math.pow(v, 2) / 2);
                    moveSprite(40, 47, delay, totalCells, index, walkingThor);
                    moveSprite(40, 47, delay, totalCells, index, runningThor);
                }
                // UpRight
                if (window.keyisdown[68] && window.keyisdown[87]) {
                    player.nextspeed.x = Math.sqrt(Math.pow(v, 2) / 2);
                    player.nextspeed.z = Math.sqrt(Math.pow(v, 2) / 2);
                    moveSprite(56, 63, delay, totalCells, index, walkingThor);
                    moveSprite(56, 63, delay, totalCells, index, runningThor);
                }
                // BottomRight
                if (window.keyisdown[68] && window.keyisdown[83]) {
                    player.nextspeed.x = Math.sqrt(Math.pow(v, 2) / 2);
                    player.nextspeed.z = - Math.sqrt(Math.pow(v, 2) / 2);
                    moveSprite(48, 55, delay, totalCells, index, walkingThor);
                    moveSprite(48, 55, delay, totalCells, index, runningThor);
                }
                // BottomLeft
                if (window.keyisdown[65] && window.keyisdown[83]) {
                    player.nextspeed.x = - Math.sqrt(Math.pow(v, 2) / 2);
                    player.nextspeed.z = - Math.sqrt(Math.pow(v, 2) / 2);
                    moveSprite(32, 39, delay, totalCells, index, walkingThor);
                    moveSprite(32, 39, delay, totalCells, index, runningThor);
                }
                // Top Three (a, w, d)
                if (window.keyisdown[87] && window.keyisdown[65] && window.keyisdown[68]) {
                    player.nextspeed.z = v;
                    moveSprite(24, 31, delay, totalCells, index, walkingThor);
                    moveSprite(24, 31, delay, totalCells, index, runningThor);
                }
                // Bottom Three (a, s, d)
                if (window.keyisdown[83] && window.keyisdown[65] && window.keyisdown[68]) {
                    player.nextspeed.z = -v;
                    moveSprite(0, 7, delay, totalCells, index, walkingThor);
                    moveSprite(0, 7, delay, totalCells, index, runningThor);
                }



                player.speed = BABYLON.Vector3.Lerp(player.speed, player.nextspeed, 0.1);
                player.moveWithCollisions(player.speed);

                // if (player.position.x > groundSize / 2 - 5) { player.position.x = groundSize / 2 - 5; }
                // if (player.position.x < -groundSize / 2 + 5) { player.position.x = -groundSize / 2 + 5; }
                // if (player.position.z > groundSize / 2 - 5) { player.position.z = groundSize / 2 - 5; }
                if (player.position.z < -groundSize / 2 + 15) { player.position.z = -groundSize / 2 + 15; }

                // player.nexttorch = lightImpostor.getAbsolutePosition();
                // torch.position.copyFrom(player.nexttorch);
                // torch.intensity = 0.7 + Math.random() * 0.1;
                // torch.position.x += Math.random() * 0.125 - 0.0625;
                // torch.position.z += Math.random() * 0.125 - 0.0625;
                // camera.target = player;
            });

            // /*********************************************************************************************************************/

            return scene1;
        }

        /* ==== Recursive Maze Function ====
        * 
        * 
        * 
        */
        function carve_passages_from(cx, cy, grid, wallArray, myStack, index) {
            // new x and y indices
            var nx;
            var ny;
            // iterator
            var i;
            // array holding cardinal directions, shuffled for random
            var N = -1; // because North is negative 1 on z axis
            var S = 1;  // because South is 1 on z axis
            var W = -2; // because West is -1 on x axis (divide by 2 everywhere else)
            var E = 2;  // opposite ^^^
            var directions = [N, S, W, E];
            shuffle(directions);
            // set 1 at current cell so we know we've been here
            grid[cy][cx] = 1;

            // console.log("cy");
            // console.log(cy);
            // console.log("cx");
            // console.log(cx);

            // loops through array of randomized directions
            for (i = 0; i < directions.length; i++) {
                if (directions[i] === E || directions[i] === W) {
                    nx = cx + directions[i] / 2;
                    ny = cy;
                }
                else {
                    // if north/south
                    nx = cx;
                    ny = cy + directions[i];
                }
                // if new cell is inbounds and not visitied previously
                if ((nx >= 0 && nx < grid[0].length) && (ny >= 0 && ny < grid.length) && grid[ny][nx] === 0) {
                    myStack.push(cx);
                    myStack.push(cy);
                    // Tear down wall
                    if (directions[i] === N) {
                        wallArray[2 * cy + 1 + N][cx].dispose();
                        delete wallArray[2 * cy + 1 + N][cx];
                        // console.log("tear down wall at:");
                        // console.log(2 * cy + 1 + N);
                        // console.log(cx);
                    }
                    if (directions[i] === S) {
                        wallArray[2 * cy + 1 + S][cx].dispose();
                        delete wallArray[2 * cy + 1 + S][cx];
                        // console.log("tear down wall at:");
                        // console.log(2 * cy + 1 + + S);
                        // console.log(cx);
                    }
                    if (directions[i] === E) {
                        wallArray[2 * cy + 1][cx + E / 2].dispose();
                        delete wallArray[2 * cy + 1][cx + E / 2];
                        // console.log("tear down wall at:");
                        // console.log(2 * cy + 1);
                        // console.log(cx + E / 2);
                    }
                    if (directions[i] === W) {
                        wallArray[2 * cy + 1][cx].dispose();
                        delete wallArray[2 * cy + 1][cx];
                        // console.log("tear down wall at:");
                        // console.log(2 * cy + 1);
                        // console.log(cx);
                    }
                    index++;
                    // console.log("moving forward");
                    carve_passages_from(nx, ny, grid, wallArray, myStack, index);
                }
            }
            // if no options available - not in for loop
            if (myStack.length === 0 && index != 0) {
                return 0;
            }
            var py = myStack.pop();
            var px = myStack.pop();
            index++;
            carve_passages_from(px, py, grid, wallArray, myStack, index);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i

                // swap elements array[i] and array[j]
                // we use "destructuring assignment" syntax to achieve that
                // you'll find more details about that syntax in later chapters
                // same can be written as:
                // let t = array[i]; array[i] = array[j]; array[j] = t
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /* ==== function moveSprite ====
         * min and max are bounds for sprite cells
         * delay is modulo number to slow down frame rate
         * total is total number of cells in sprite
         * index is used for slowing frame rate
         * walkingThor is sprite object
         */
        function moveSprite(min, max, delay, total, index, walkingThor) {
            if (index % delay === 0) {
                if (walkingThor.cellIndex < min || walkingThor.cellIndex > max) {
                    walkingThor.cellIndex = min;
                }
                walkingThor.cellIndex = (walkingThor.cellIndex + 1) % (total + 1);
                if (walkingThor.cellIndex > max) {
                    walkingThor.cellIndex = min;
                }
            }
        }

        function sleep(milliseconds) {
            const date = Date.now();
            let currentDate = null;
            do {
                currentDate = Date.now();
            } while (currentDate - date < milliseconds);
        }


        engine = createDefaultEngine();
        if (!engine) throw 'engine should not be null.';
        if (!nextScene) {
            scene0 = createScene0();
        } else {
            scene1 = createScene1();
        }

        var time = 0.0;
        function timer() {
            time += 0.001;
        }
        if (true) {
            setTimeout('timer()', 1);
            console.log("Time:");
            console.log(time);
        }

        // gui for Home Menu
        var scene0GUI = function () {
            var cornerRadius = 10;
            var squareSide = 200;
            var buttonPadding = 50;

            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene0);
            // advancedTexture.renderAtIdealSize = true;
            advancedTexture.useSmallestIdeal = true;
            advancedTexture.idealWidth = 1300;
            advancedTexture.idealHeight = 1300;

            var panel3 = new BABYLON.GUI.StackPanel();
            advancedTexture.addControl(panel3);

            var panel = new BABYLON.GUI.StackPanel();
            panel.isVertical = false;
            panel.top = "95px";
            advancedTexture.addControl(panel);

            var panel2 = new BABYLON.GUI.StackPanel();
            panel2.top = "-200px";
            advancedTexture.addControl(panel2);

            // Easy Level Button
            var easyButton = BABYLON.GUI.Button.CreateImageWithCenterTextButton("but", "", "images/easy.png");
            easyButton.width = squareSide.toString() + "px";
            easyButton.height = squareSide.toString() + "px";
            easyButton.cornerRadius = cornerRadius;
            easyButton.verticalAlignment = 2
            easyButton.isPointerBlocker = true
            easyButton.onPointerUpObservable.add(function () {
                advancedTexture.dispose();
                nextScene = true;
                replay = true;
                soundtrack.pause();
                sub = 10;
                scene0 = null;
                scene1 = createScene1();
                scene1GUI();
            });
            panel.addControl(easyButton);

            // Medium Level Button
            var mediumButton = BABYLON.GUI.Button.CreateImageWithCenterTextButton("but2", "", "images/medium.png");
            mediumButton.width = (squareSide + buttonPadding).toString() + "px";
            mediumButton.height = squareSide.toString() + "px";
            mediumButton.paddingLeft = buttonPadding.toString() + "px";
            mediumButton.cornerRadius = cornerRadius;
            mediumButton.verticalAlignment = 2
            mediumButton.isPointerBlocker = true
            mediumButton.onPointerUpObservable.add(function () {
                advancedTexture.dispose();
                nextScene = true;
                replay = true;
                soundtrack.pause();
                sub = 20;
                scene0 = null;
                scene1 = createScene1();
                scene1GUI();
            });

            panel.addControl(mediumButton);

            // Hard Level Button
            var hardButton = BABYLON.GUI.Button.CreateImageWithCenterTextButton("but3", "", "images/hard.png");
            hardButton.width = (squareSide + buttonPadding).toString() + "px";
            hardButton.height = squareSide.toString() + "px";
            hardButton.paddingLeft = buttonPadding.toString() + "px";
            hardButton.cornerRadius = cornerRadius;
            hardButton.verticalAlignment = 2
            hardButton.isPointerBlocker = true
            hardButton.onPointerUpObservable.add(function () {
                advancedTexture.dispose();
                nextScene = true;
                replay = true;
                soundtrack.pause();
                sub = 30;
                scene0 = null;
                scene1 = createScene1();
                scene1GUI();
            });

            panel.addControl(hardButton);

            // Game Logo
            var logo = new BABYLON.GUI.Image("but4", "images/mazerunner_logo.png");
            logo.width = "400px";
            logo.height = "200px";
            panel2.addControl(logo);

            // Background
            var background = new BABYLON.GUI.Image("but5", "images/background.png");
            background.width = 1;
            background.height = "1500px";
            panel3.addControl(background);

            var text1 = new BABYLON.GUI.TextBlock();
            text1.text = "Time: " + time.toString(5) + " s";
            text1.color = "white";
            text1.fontSize = 24;
            text1.lineSpacing = "5px";
            panel2.textHorizontalAlignment = 1;
            panel2.textVerticalAlignment = 1;
            panel2.addControl(text1);
        }
        if (!nextScene) {
            scene0GUI();
        }

        // GUI for Game
        var scene1GUI = function () {
            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene1);
            var panel = new BABYLON.GUI.StackPanel();
            panel.isVertical = false;
            panel.horizontalAlignment = 0;
            panel.verticalAlignment = 2;
            advancedTexture.addControl(panel);

            var panel2 = new BABYLON.GUI.StackPanel();
            panel2.top = "-200px";
            advancedTexture.addControl(panel2);

            var homeButton = BABYLON.GUI.Button.CreateImageWithCenterTextButton("but", "Home Menu", "");
            homeButton.width = "75px";
            homeButton.height = "50px";
            homeButton.color = "gray";
            homeButton.background = "black";
            homeButton.cornerRadius = 0;
            homeButton.verticalAlignment = 1;
            homeButton.horizontalAlignment = 0;
            homeButton.isPointerBlocker = true
            homeButton.onPointerUpObservable.add(function () {
                advancedTexture.dispose();
                nextScene = false;
                soundtrack.pause();
                scene1 = null;
                scene0 = createScene0();
                scene0GUI();
            });
            panel.addControl(homeButton);

            var resetButton = BABYLON.GUI.Button.CreateImageWithCenterTextButton("but", "Reset Maze", "");
            resetButton.width = "75px";
            resetButton.height = "50px";
            resetButton.color = "gray";
            resetButton.background = "black";
            resetButton.cornerRadius = 0;
            resetButton.verticalAlignment = 1;
            resetButton.horizontalAlignment = 0;
            resetButton.isPointerBlocker = true
            resetButton.onPointerUpObservable.add(function () {
                advancedTexture.dispose();
                replay = false;
                scene1 = null;
                scene1 = createScene1();
                scene1GUI();
            });
            panel.addControl(resetButton);


        }
        if (nextScene) {
            scene1GUI();
        }

        engine.runRenderLoop(function () {
            if (!nextScene && scene0) {
                scene0.render();
            }
            else if (scene1) {
                scene1.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>